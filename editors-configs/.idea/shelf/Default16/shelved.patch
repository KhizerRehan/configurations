Index: src/app/shared/components/elements/element-multi-select-v2/element-multi-select-v2.component.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import { Component, EventEmitter, Input, OnChanges, OnDestroy, Output, ViewChild } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport { Subject } from 'rxjs/Subject';\nimport { ElementHandlerService } from '../../../../core/services/element-handler.service';\nimport { HttpApiService } from '../../../../core/services/http-api.service';\nimport { RequestMode } from '../../../../core/services/request-mode.enum';\nimport { RequestBuilder } from '../../../../core/services/request.builder';\nimport { ResponseCode } from '../../../../core/services/ResponseCode';\nimport { SharedDataService } from '../../../../core/services/shared-data.service';\nimport { TransactionService } from '../../../../core/services/transaction.service';\nimport { ConfirmModal } from '../../modals/confrim-modal/confirm-modal.component';\n\n@Component({\n  selector: 'app-element-multi-select-v2',\n  templateUrl: './element-multi-select-v2.component.html'\n})\nexport class ElementMultiSelectV2Component implements OnChanges, OnDestroy {\n  readonly destroyed$ = new Subject();\n\n  @Input() confirmBeforeRemoving: boolean;\n  @Input() confirmationTitleAndMessage: any = {};\n  @Input() filterItems: Array<any> = [];\n  @Input() data: any;\n  @Input() items: Array<string>;\n  @Input() url: string;\n  @Input() canCreateNew: boolean;\n  @Input() canUpdate: boolean = true;\n  @Input() clearValueOnDestroy: boolean;\n  @Input() isValueProvided: boolean;\n  @Input() isDomainOriginOnly: boolean;\n  @Input() setValueWhenDelete: boolean;\n  @Input() newBtnLabel: string;\n  @Input() allowClear: boolean = true;\n\n  @Output() valueChanged = new EventEmitter();\n  @Output() error = new EventEmitter();\n  @Output() valueSelected = new EventEmitter();\n\n  @ViewChild('multiSelectElement') private multiSelectElement;\n  @ViewChild('addItemInput') private addItemInput;\n\n  errorMessage: any;\n  leafrefTarget: string;\n  isElementBusyIncremented: boolean = false;\n  itemToRemove: string;\n  dropdownToggle: boolean = false;\n  isAddingNew: boolean;\n  newValue: string;\n  searchValue: string = '';\n  hasError: boolean;\n  isEditValue: boolean;\n  selectedValue: any;\n\n  private valueToEdit: string;\n  private previousValue: any;\n\n  constructor(private Transaction: TransactionService,\n              private Api: HttpApiService,\n              private sharedData: SharedDataService,\n              private elementHandler: ElementHandlerService) {\n  }\n\n  ngOnChanges(changes: any) {\n    if (changes.data && changes.data.currentValue) {\n      this.data = changes.data.currentValue;\n      this.data.path = this.url ? this.url : this.data.path;\n      this.loadValues();\n      if (this.data.items || this.items) {\n        if (this.items && this.items.length > 0) {\n          this.items = this.items.filter(item => this.filterItems.indexOf(item) < 0).sort();\n        }\n        else if (this.data.items && this.data.items.length > 0) {\n          this.items = this.data.items.filter(item => this.filterItems.indexOf(item) < 0).sort();\n        }\n        return;\n      }\n      else if (this.data.leafrefTarget && this.leafrefTarget !== this.data.leafrefTarget && !this.data.xpath_expr) {\n        this.loadItems();\n      }\n      else if (this.data.xpath_expr) {\n        this.queryItems();\n      }\n      this.leafrefTarget = this.data.leafrefTarget;\n      this.elementHandler.focusOnElement(this.data, this.multiSelectElement);\n    }\n    if (changes.filterItems && changes.filterItems.currentValue) {\n      this.filterItems = changes.filterItems.currentValue;\n      if (this.items && this.items.length > 0) {\n        this.items = this.items.filter(item => this.filterItems.indexOf(item) < 0).sort();\n      }\n    }\n    if (changes.url && changes.url.currentValue && this.data) {\n      this.data.path = changes.url.currentValue;\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.isElementBusyIncremented) {\n      this.sharedData.decrementElementsBusyCounter();\n      this.isElementBusyIncremented = false;\n    }\n    if (this.clearValueOnDestroy) {\n      this.data.value = this.data.default || null;\n    }\n    this.destroyed$.next(true);\n    this.destroyed$.complete();\n  }\n\n  loadValues() {\n    if (this.isValueProvided) {\n      this.getValueCompleted();\n    }\n    else {\n      if (!this.isElementBusyIncremented) {\n        this.sharedData.incrementElementsBusyCounter();\n        this.isElementBusyIncremented = true;\n      }\n      this.Transaction.getReadTransaction().then(transactionId => {\n        this.sharedData.getValue(this.data.path, this.Api, transactionId, this.data, this, 'getValueCompleted');\n      });\n    }\n  }\n\n  getValueCompleted() {\n    if (this.data.error) {\n      this.error.emit({requestMode: RequestMode.READ, error: this.data.error, path: this.data.path});\n    }\n    if (this.data.value && this.data.presenceContainer) {\n      this.data.isPresenceContainerCreated = true;\n    }\n    this.data.value = this.data.value || this.data.default || [];\n    this.previousValue = [...this.data.value];\n    if (this.isElementBusyIncremented) {\n      this.sharedData.decrementElementsBusyCounter();\n      this.isElementBusyIncremented = false;\n    }\n    this.filterSelectedValues();\n  }\n\n  toggleDropdown(searchInput: any) {\n    this.dropdownToggle = !this.dropdownToggle;\n    if (this.dropdownToggle) {\n      setTimeout(() => {\n        searchInput.focus();\n      }, 100);\n    }\n  }\n\n  updateData() {\n    this.data.hasError = false;\n    this.errorMessage = null;\n    if (!this.data.value || this.data.value.length === 0) {\n      this.deletePath();\n      return;\n    }\n    if (this.data.presenceContainer && !this.data.isPresenceContainerCreated) {\n      this.createPath(this.data.containerPath)\n        .takeUntil(this.destroyed$)\n        .subscribe(response => {\n            if (!response.hasError) {\n              this.data.isPresenceContainerCreated = true;\n              this.setValue();\n            }\n          },\n          error => console.log(error));\n    }\n    else {\n      this.setValue();\n    }\n  }\n\n  deleteItem(value: string) {\n    this.data.hasError = false;\n    this.errorMessage = null;\n    this.Transaction.getWriteTransaction()\n      .then(transaction => {\n        this.Api.postRequest(RequestBuilder.withDeleteValue(value, this.data.path, transaction))\n          .takeUntil(this.destroyed$)\n          .subscribe(response => {\n              if (response.code !== ResponseCode.OK) {\n                this.errorMessage = response;\n                this.error.emit({requestMode: RequestMode.WRITE, error: response, path: this.data.path});\n              }\n              else {\n                this.previousValue = [...this.data.value];\n                this.sharedData.incrementChangeCount(this.data.path);\n                this.valueChanged.emit({value: this.data.value, element: this.data.name, error: false, path: this.data.path});\n              }\n            },\n            error => console.log(error));\n      })\n      .catch(error => {\n        this.data.value = [...this.previousValue];\n      });\n  }\n\n  deletePath() {\n    this.Transaction.getWriteTransaction()\n      .then(transaction => {\n        this.Api.postRequest(RequestBuilder.withDelete(this.data.path, transaction))\n          .takeUntil(this.destroyed$)\n          .subscribe(response => {\n              if (response.code !== ResponseCode.OK) {\n                this.errorMessage = response;\n                console.log('Error in field :', this.data.name, '   response ', response);\n                this.error.emit({requestMode: RequestMode.WRITE, error: response, path: this.data.path});\n              }\n              else {\n                this.previousValue = [...this.data.value];\n                this.sharedData.incrementChangeCount(this.data.path);\n                this.valueChanged.emit({value: this.data.value, element: this.data.name, error: false, path: this.data.path});\n              }\n            },\n            error => console.log(error));\n      })\n      .catch(error => {\n        this.data.value = [...this.previousValue];\n      });\n  }\n\n  selected(value: string) {\n    this.data.value.push(value);\n    this.items = this.items.filter(item => item !== value);\n    if (this.canUpdate) {\n      this.updateData();\n    }\n    else {\n      this.previousValue = [...this.data.value];\n      this.valueChanged.emit({value: this.data.value, element: this.data.name, error: false, path: this.data.path, selectedItem: value});\n    }\n  }\n\n  addItem() {\n    this.hasError = false;\n    this.newValue = this.newValue ? this.newValue.trim() : '';\n    if (this.isDomainOriginOnly) {\n      this.newValue = this.fetchDomainOrigin(this.newValue);\n    }\n    if (this.newValue && this.data.value.indexOf(this.newValue) < 0) {\n      if (this.isEditValue) {\n        const index = this.data.value.indexOf(this.valueToEdit);\n        if (index > -1) {\n          this.data.value[index] = this.newValue;\n        }\n        else {\n          this.data.value.push(this.newValue);\n        }\n      }\n      else {\n        this.data.value.push(this.newValue);\n      }\n      if (this.canUpdate) {\n        this.updateData();\n      }\n      else {\n        this.previousValue = [...this.data.value];\n        this.valueChanged.emit({value: this.data.value, element: this.data.name, error: false, path: this.data.path});\n      }\n      this.newValue = '';\n      this.valueToEdit = null;\n      this.isEditValue = false;\n    }\n    else if (this.newValue === this.valueToEdit) {\n      this.newValue = '';\n      this.valueToEdit = null;\n      this.isEditValue = false;\n    }\n  }\n\n  removed(value: string) {\n    this.itemToRemove = value;\n    if (this.confirmBeforeRemoving) {\n      ConfirmModal.open(\n        this.confirmationTitleAndMessage.title || 'Remove Item',\n        this.confirmationTitleAndMessage.message || `Are you sure you want to remove item <em>${value}</em>?`,\n        'removeItemConfirmed',\n        this\n      );\n    }\n    else {\n      this.removeItemConfirmed();\n    }\n  }\n\n  removeItemConfirmed() {\n    if (this.itemToRemove) {\n      this.data.value.splice(this.data.value.indexOf(this.itemToRemove), 1);\n      if (this.setValueWhenDelete) {\n        if (this.canUpdate) {\n          this.updateData();\n        }\n        else {\n          this.previousValue = [...this.data.value];\n          this.valueChanged.emit({\n            value: this.data.value,\n            element: this.data.name,\n            error: false,\n            path: this.data.path,\n            isRemoved: true,\n            removedItem: this.itemToRemove\n          });\n        }\n      }\n      else {\n        if (this.items) {\n          this.items = [...this.items, this.itemToRemove].sort();\n        }\n        if (this.canUpdate) {\n          this.deleteItem(this.itemToRemove);\n        }\n        else {\n          this.previousValue = [...this.data.value];\n          this.valueChanged.emit({\n            value: this.data.value,\n            element: this.data.name,\n            error: false,\n            path: this.data.path,\n            isRemoved: true,\n            removedItem: this.itemToRemove\n          });\n        }\n      }\n    }\n  }\n\n  onCreateNewLeaf() {\n    this.newValue = '';\n    this.isAddingNew = true;\n  }\n\n  createNewLeaf() {\n    this.newValue = this.newValue ? this.newValue.trim() : '';\n    if (this.newValue) {\n      this.errorMessage = null;\n      this.Transaction.getWriteTransaction()\n        .then(transactionId => {\n          const path = `${this.data.leafrefTarget}{${this.newValue}}`;\n          this.Api.postRequest(RequestBuilder.withCreate(path, transactionId))\n            .takeUntil(this.destroyed$)\n            .subscribe(response => {\n              if (response.code === ResponseCode.OK) {\n                this.sharedData.incrementChangeCount(path);\n                this.items = [...this.items, this.newValue];\n                this.selected(this.newValue);\n                this.isAddingNew = false;\n              }\n              else {\n                this.errorMessage = response;\n              }\n            });\n        })\n      .catch(error => {});\n    }\n  }\n\n  editValue(value: string) {\n    this.selectedValue = value;\n    this.valueSelected.emit(this.selectedValue);\n    if (this.addItemInput) {\n      this.valueToEdit = value;\n      this.isEditValue = true;\n      this.newValue = value;\n      this.addItemInput.nativeElement.focus();\n    }\n  }\n\n  private loadItems() {\n    this.data.leafrefTarget = this.data.leafrefTarget.replace(new RegExp('base:', 'g'), '');\n    this.data.leafrefTarget = this.data.leafrefTarget.replace('/id', '');\n\n    this.Transaction.getReadTransaction()\n      .then(transaction => {\n        this.Api.postRequest(RequestBuilder.withGetListKeys(this.data.leafrefTarget, transaction))\n          .takeUntil(this.destroyed$)\n          .subscribe(response => {\n              if (response.code !== ResponseCode.OK) {\n                console.log('Error in field :', this.data.name, '   response ', response);\n                this.error.emit({requestMode: RequestMode.READ, error: response, path: this.data.leafrefTarget});\n              }\n              else {\n                const items = [];\n                if (this.data && this.data['min-elements'] > 0) {\n                  this.data.mandatory = true;\n                }\n                response.data.keys.forEach((value: any) => {\n                  if (this.filterItems.indexOf(value.id) < 0) {\n                    items.push(value.id);\n                  }\n                });\n                this.items = items.sort();\n                this.filterSelectedValues();\n              }\n            },\n            error => console.log(error));\n      });\n  }\n\n  private queryItems() {\n    this.Transaction.getReadTransaction()\n      .then(transaction => {\n        this.Api.postRequest(RequestBuilder.withQuery(this.data.xpath_expr, transaction))\n          .takeUntil(this.destroyed$)\n          .subscribe(response => {\n              const items = [];\n              response.data.results.forEach(item => {\n                if (this.filterItems.indexOf(item.id.value) < 0) {\n                  items.push(item.id.value);\n                }\n              });\n              this.items = items.sort();\n              this.filterSelectedValues();\n            },\n            error => console.log(error));\n      });\n  }\n\n  private filterSelectedValues() {\n    if (this.items && this.data.value) {\n      this.items = this.items.filter(item => this.data.value.indexOf(item) === -1);\n    }\n  }\n\n  private createPath(path: string): Observable<any> {\n    return Observable.create(observer => {\n      this.Transaction.getWriteTransaction()\n        .then(transactionId => {\n          return this.Api.postRequest(RequestBuilder.withCreate(path, transactionId))\n            .takeUntil(this.destroyed$)\n            .finally(() => observer.complete())\n            .subscribe(response => {\n                if (response.code === ResponseCode.OK) {\n                  this.sharedData.incrementChangeCount(path);\n                  observer.next({hasError: false, response});\n                }\n                else {\n                  this.errorMessage = response;\n                  this.error.emit({requestMode: RequestMode.WRITE, error: response, path: path});\n                  observer.next({hasError: true, response});\n                }\n              },\n              error => observer.error(error));\n        })\n      .catch(error => {\n        this.data.value = [...this.previousValue];\n        observer.error(error);\n      });\n    });\n  }\n\n  private setValue() {\n    this.Transaction.getWriteTransaction()\n      .then(transaction => {\n        this.Api.postRequest(RequestBuilder.withSetValue(this.data.value, this.data.path, transaction))\n          .takeUntil(this.destroyed$)\n          .subscribe(response => {\n              if (response.code !== ResponseCode.OK) {\n                this.errorMessage = response;\n                this.data.value = [...this.previousValue];\n                this.error.emit({requestMode: RequestMode.WRITE, error: response, path: this.data.path});\n              }\n              else {\n                this.previousValue = [...this.data.value];\n                this.sharedData.incrementChangeCount(this.data.path);\n                this.valueChanged.emit({value: this.data.value, element: this.data.name, error: false, path: this.data.path});\n              }\n            },\n            error => console.log(error));\n      })\n      .catch(error => {\n        this.data.value = [...this.previousValue];\n      });\n  }\n\n  private fetchDomainOrigin(value: string) {\n    if (value) {\n      const tokens = value.split('/').filter(token => !!token);\n      if (tokens.length > 1 && (tokens[0] === 'http:' || tokens[0] === 'https:')) {\n        return tokens[0] + '//' + tokens[1];\n      }\n      else {\n        this.hasError = true;\n      }\n    }\n    return null;\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/app/shared/components/elements/element-multi-select-v2/element-multi-select-v2.component.ts	(revision 74139ab30601b6655567df211f13e7f0c8898955)
+++ src/app/shared/components/elements/element-multi-select-v2/element-multi-select-v2.component.ts	(date 1550754637000)
@@ -49,7 +49,6 @@
   searchValue: string = '';
   hasError: boolean;
   isEditValue: boolean;
-  selectedValue: any;
 
   private valueToEdit: string;
   private previousValue: any;
@@ -354,8 +353,7 @@
   }
 
   editValue(value: string) {
-    this.selectedValue = value;
-    this.valueSelected.emit(this.selectedValue);
+    this.valueSelected.emit(value);
     if (this.addItemInput) {
       this.valueToEdit = value;
       this.isEditValue = true;
